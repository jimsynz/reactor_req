<!--
This file was generated by Spark. Do not edit it by hand.
-->
# DSL: Reactor.Req

An extension which provides direct support for working with `req` requests
within Reactor.



## reactor.req_delete
```elixir
req_delete name
```


Performs a request using `Req.delete/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_delete-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_delete-name){: #reactor-req_delete-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_delete-adapter){: #reactor-req_delete-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_delete-auth){: #reactor-req_delete-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_delete-aws_sigv4){: #reactor-req_delete-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_delete-base_url){: #reactor-req_delete-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_delete-body){: #reactor-req_delete-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_delete-cache_dir){: #reactor-req_delete-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_delete-cache){: #reactor-req_delete-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_delete-compress_body){: #reactor-req_delete-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_delete-connect_options){: #reactor-req_delete-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_delete-decode_body){: #reactor-req_delete-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_delete-decode_json){: #reactor-req_delete-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_delete-finch_private){: #reactor-req_delete-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_delete-finch_request){: #reactor-req_delete-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_delete-finch){: #reactor-req_delete-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_delete-form_multipart){: #reactor-req_delete-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_delete-form){: #reactor-req_delete-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_delete-headers){: #reactor-req_delete-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_delete-http_errors){: #reactor-req_delete-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_delete-inet6){: #reactor-req_delete-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_delete-into){: #reactor-req_delete-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_delete-json){: #reactor-req_delete-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_delete-max_redirects){: #reactor-req_delete-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_delete-max_retries){: #reactor-req_delete-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_delete-method){: #reactor-req_delete-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_delete-params){: #reactor-req_delete-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_delete-path_params_style){: #reactor-req_delete-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_delete-path_params){: #reactor-req_delete-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_delete-plug){: #reactor-req_delete-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_delete-pool_timeout){: #reactor-req_delete-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_delete-raw){: #reactor-req_delete-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_delete-receive_timeout){: #reactor-req_delete-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_delete-redirect_trusted){: #reactor-req_delete-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_delete-redirect){: #reactor-req_delete-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_delete-request){: #reactor-req_delete-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_delete-retry_delay){: #reactor-req_delete-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_delete-retry_log_level){: #reactor-req_delete-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_delete-retry){: #reactor-req_delete-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_delete-unix_socket){: #reactor-req_delete-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_delete-url){: #reactor-req_delete-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_delete.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_delete-wait_for-names){: #reactor-req_delete-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Delete`



## reactor.req_get
```elixir
req_get name
```


Performs a request using `Req.get/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_get-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_get-name){: #reactor-req_get-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_get-adapter){: #reactor-req_get-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_get-auth){: #reactor-req_get-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_get-aws_sigv4){: #reactor-req_get-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_get-base_url){: #reactor-req_get-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_get-body){: #reactor-req_get-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_get-cache_dir){: #reactor-req_get-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_get-cache){: #reactor-req_get-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_get-compress_body){: #reactor-req_get-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_get-connect_options){: #reactor-req_get-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_get-decode_body){: #reactor-req_get-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_get-decode_json){: #reactor-req_get-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_get-finch_private){: #reactor-req_get-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_get-finch_request){: #reactor-req_get-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_get-finch){: #reactor-req_get-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_get-form_multipart){: #reactor-req_get-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_get-form){: #reactor-req_get-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_get-headers){: #reactor-req_get-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_get-http_errors){: #reactor-req_get-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_get-inet6){: #reactor-req_get-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_get-into){: #reactor-req_get-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_get-json){: #reactor-req_get-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_get-max_redirects){: #reactor-req_get-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_get-max_retries){: #reactor-req_get-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_get-method){: #reactor-req_get-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_get-params){: #reactor-req_get-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_get-path_params_style){: #reactor-req_get-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_get-path_params){: #reactor-req_get-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_get-plug){: #reactor-req_get-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_get-pool_timeout){: #reactor-req_get-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_get-raw){: #reactor-req_get-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_get-receive_timeout){: #reactor-req_get-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_get-redirect_trusted){: #reactor-req_get-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_get-redirect){: #reactor-req_get-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_get-request){: #reactor-req_get-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_get-retry_delay){: #reactor-req_get-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_get-retry_log_level){: #reactor-req_get-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_get-retry){: #reactor-req_get-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_get-unix_socket){: #reactor-req_get-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_get-url){: #reactor-req_get-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_get.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_get-wait_for-names){: #reactor-req_get-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Get`



## reactor.req_head
```elixir
req_head name
```


Performs a request using `Req.head/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_head-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_head-name){: #reactor-req_head-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_head-adapter){: #reactor-req_head-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_head-auth){: #reactor-req_head-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_head-aws_sigv4){: #reactor-req_head-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_head-base_url){: #reactor-req_head-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_head-body){: #reactor-req_head-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_head-cache_dir){: #reactor-req_head-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_head-cache){: #reactor-req_head-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_head-compress_body){: #reactor-req_head-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_head-connect_options){: #reactor-req_head-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_head-decode_body){: #reactor-req_head-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_head-decode_json){: #reactor-req_head-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_head-finch_private){: #reactor-req_head-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_head-finch_request){: #reactor-req_head-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_head-finch){: #reactor-req_head-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_head-form_multipart){: #reactor-req_head-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_head-form){: #reactor-req_head-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_head-headers){: #reactor-req_head-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_head-http_errors){: #reactor-req_head-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_head-inet6){: #reactor-req_head-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_head-into){: #reactor-req_head-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_head-json){: #reactor-req_head-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_head-max_redirects){: #reactor-req_head-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_head-max_retries){: #reactor-req_head-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_head-method){: #reactor-req_head-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_head-params){: #reactor-req_head-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_head-path_params_style){: #reactor-req_head-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_head-path_params){: #reactor-req_head-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_head-plug){: #reactor-req_head-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_head-pool_timeout){: #reactor-req_head-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_head-raw){: #reactor-req_head-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_head-receive_timeout){: #reactor-req_head-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_head-redirect_trusted){: #reactor-req_head-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_head-redirect){: #reactor-req_head-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_head-request){: #reactor-req_head-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_head-retry_delay){: #reactor-req_head-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_head-retry_log_level){: #reactor-req_head-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_head-retry){: #reactor-req_head-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_head-unix_socket){: #reactor-req_head-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_head-url){: #reactor-req_head-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_head.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_head-wait_for-names){: #reactor-req_head-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Head`



## reactor.req_merge
```elixir
req_merge name
```


Creates a new request using `Req.merge/2`

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_merge-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_merge-name){: #reactor-req_merge-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_merge-adapter){: #reactor-req_merge-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_merge-auth){: #reactor-req_merge-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_merge-aws_sigv4){: #reactor-req_merge-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_merge-base_url){: #reactor-req_merge-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_merge-body){: #reactor-req_merge-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_merge-cache_dir){: #reactor-req_merge-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_merge-cache){: #reactor-req_merge-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_merge-compress_body){: #reactor-req_merge-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_merge-connect_options){: #reactor-req_merge-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_merge-decode_body){: #reactor-req_merge-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_merge-decode_json){: #reactor-req_merge-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_merge-finch_private){: #reactor-req_merge-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_merge-finch_request){: #reactor-req_merge-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_merge-finch){: #reactor-req_merge-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_merge-form_multipart){: #reactor-req_merge-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_merge-form){: #reactor-req_merge-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_merge-headers){: #reactor-req_merge-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_merge-http_errors){: #reactor-req_merge-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_merge-inet6){: #reactor-req_merge-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_merge-into){: #reactor-req_merge-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_merge-json){: #reactor-req_merge-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_merge-max_redirects){: #reactor-req_merge-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_merge-max_retries){: #reactor-req_merge-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_merge-method){: #reactor-req_merge-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_merge-params){: #reactor-req_merge-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_merge-path_params_style){: #reactor-req_merge-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_merge-path_params){: #reactor-req_merge-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_merge-plug){: #reactor-req_merge-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_merge-pool_timeout){: #reactor-req_merge-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_merge-raw){: #reactor-req_merge-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_merge-receive_timeout){: #reactor-req_merge-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_merge-redirect_trusted){: #reactor-req_merge-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_merge-redirect){: #reactor-req_merge-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_merge-request){: #reactor-req_merge-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_merge-retry_delay){: #reactor-req_merge-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_merge-retry_log_level){: #reactor-req_merge-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_merge-retry){: #reactor-req_merge-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_merge-unix_socket){: #reactor-req_merge-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_merge-url){: #reactor-req_merge-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_merge.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_merge-wait_for-names){: #reactor-req_merge-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Merge`



## reactor.req_new
```elixir
req_new name
```


Creates a new request using `Req.new/1`

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_new-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_new-name){: #reactor-req_new-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_new-adapter){: #reactor-req_new-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_new-auth){: #reactor-req_new-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_new-aws_sigv4){: #reactor-req_new-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_new-base_url){: #reactor-req_new-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_new-body){: #reactor-req_new-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_new-cache_dir){: #reactor-req_new-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_new-cache){: #reactor-req_new-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_new-compress_body){: #reactor-req_new-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_new-connect_options){: #reactor-req_new-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_new-decode_body){: #reactor-req_new-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_new-decode_json){: #reactor-req_new-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_new-finch_private){: #reactor-req_new-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_new-finch_request){: #reactor-req_new-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_new-finch){: #reactor-req_new-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_new-form_multipart){: #reactor-req_new-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_new-form){: #reactor-req_new-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_new-headers){: #reactor-req_new-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_new-http_errors){: #reactor-req_new-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_new-inet6){: #reactor-req_new-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_new-into){: #reactor-req_new-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_new-json){: #reactor-req_new-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_new-max_redirects){: #reactor-req_new-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_new-max_retries){: #reactor-req_new-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_new-method){: #reactor-req_new-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_new-params){: #reactor-req_new-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_new-path_params_style){: #reactor-req_new-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_new-path_params){: #reactor-req_new-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_new-plug){: #reactor-req_new-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_new-pool_timeout){: #reactor-req_new-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_new-raw){: #reactor-req_new-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_new-receive_timeout){: #reactor-req_new-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_new-redirect_trusted){: #reactor-req_new-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_new-redirect){: #reactor-req_new-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_new-request){: #reactor-req_new-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_new-retry_delay){: #reactor-req_new-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_new-retry_log_level){: #reactor-req_new-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_new-retry){: #reactor-req_new-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_new-unix_socket){: #reactor-req_new-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_new-url){: #reactor-req_new-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_new.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_new-wait_for-names){: #reactor-req_new-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.New`



## reactor.req_patch
```elixir
req_patch name
```


Performs a request using `Req.patch/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_patch-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_patch-name){: #reactor-req_patch-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_patch-adapter){: #reactor-req_patch-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_patch-auth){: #reactor-req_patch-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_patch-aws_sigv4){: #reactor-req_patch-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_patch-base_url){: #reactor-req_patch-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_patch-body){: #reactor-req_patch-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_patch-cache_dir){: #reactor-req_patch-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_patch-cache){: #reactor-req_patch-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_patch-compress_body){: #reactor-req_patch-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_patch-connect_options){: #reactor-req_patch-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_patch-decode_body){: #reactor-req_patch-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_patch-decode_json){: #reactor-req_patch-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_patch-finch_private){: #reactor-req_patch-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_patch-finch_request){: #reactor-req_patch-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_patch-finch){: #reactor-req_patch-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_patch-form_multipart){: #reactor-req_patch-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_patch-form){: #reactor-req_patch-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_patch-headers){: #reactor-req_patch-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_patch-http_errors){: #reactor-req_patch-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_patch-inet6){: #reactor-req_patch-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_patch-into){: #reactor-req_patch-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_patch-json){: #reactor-req_patch-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_patch-max_redirects){: #reactor-req_patch-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_patch-max_retries){: #reactor-req_patch-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_patch-method){: #reactor-req_patch-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_patch-params){: #reactor-req_patch-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_patch-path_params_style){: #reactor-req_patch-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_patch-path_params){: #reactor-req_patch-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_patch-plug){: #reactor-req_patch-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_patch-pool_timeout){: #reactor-req_patch-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_patch-raw){: #reactor-req_patch-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_patch-receive_timeout){: #reactor-req_patch-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_patch-redirect_trusted){: #reactor-req_patch-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_patch-redirect){: #reactor-req_patch-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_patch-request){: #reactor-req_patch-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_patch-retry_delay){: #reactor-req_patch-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_patch-retry_log_level){: #reactor-req_patch-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_patch-retry){: #reactor-req_patch-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_patch-unix_socket){: #reactor-req_patch-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_patch-url){: #reactor-req_patch-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_patch.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_patch-wait_for-names){: #reactor-req_patch-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Patch`



## reactor.req_post
```elixir
req_post name
```


Performs a request using `Req.post/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_post-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_post-name){: #reactor-req_post-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_post-adapter){: #reactor-req_post-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_post-auth){: #reactor-req_post-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_post-aws_sigv4){: #reactor-req_post-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_post-base_url){: #reactor-req_post-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_post-body){: #reactor-req_post-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_post-cache_dir){: #reactor-req_post-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_post-cache){: #reactor-req_post-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_post-compress_body){: #reactor-req_post-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_post-connect_options){: #reactor-req_post-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_post-decode_body){: #reactor-req_post-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_post-decode_json){: #reactor-req_post-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_post-finch_private){: #reactor-req_post-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_post-finch_request){: #reactor-req_post-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_post-finch){: #reactor-req_post-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_post-form_multipart){: #reactor-req_post-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_post-form){: #reactor-req_post-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_post-headers){: #reactor-req_post-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_post-http_errors){: #reactor-req_post-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_post-inet6){: #reactor-req_post-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_post-into){: #reactor-req_post-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_post-json){: #reactor-req_post-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_post-max_redirects){: #reactor-req_post-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_post-max_retries){: #reactor-req_post-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_post-method){: #reactor-req_post-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_post-params){: #reactor-req_post-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_post-path_params_style){: #reactor-req_post-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_post-path_params){: #reactor-req_post-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_post-plug){: #reactor-req_post-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_post-pool_timeout){: #reactor-req_post-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_post-raw){: #reactor-req_post-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_post-receive_timeout){: #reactor-req_post-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_post-redirect_trusted){: #reactor-req_post-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_post-redirect){: #reactor-req_post-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_post-request){: #reactor-req_post-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_post-retry_delay){: #reactor-req_post-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_post-retry_log_level){: #reactor-req_post-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_post-retry){: #reactor-req_post-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_post-unix_socket){: #reactor-req_post-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_post-url){: #reactor-req_post-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_post.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_post-wait_for-names){: #reactor-req_post-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Post`



## reactor.req_put
```elixir
req_put name
```


Performs a request using `Req.put/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_put-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_put-name){: #reactor-req_put-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_put-adapter){: #reactor-req_put-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_put-auth){: #reactor-req_put-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_put-aws_sigv4){: #reactor-req_put-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_put-base_url){: #reactor-req_put-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_put-body){: #reactor-req_put-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_put-cache_dir){: #reactor-req_put-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_put-cache){: #reactor-req_put-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_put-compress_body){: #reactor-req_put-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_put-connect_options){: #reactor-req_put-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_put-decode_body){: #reactor-req_put-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_put-decode_json){: #reactor-req_put-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_put-finch_private){: #reactor-req_put-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_put-finch_request){: #reactor-req_put-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_put-finch){: #reactor-req_put-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_put-form_multipart){: #reactor-req_put-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_put-form){: #reactor-req_put-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_put-headers){: #reactor-req_put-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_put-http_errors){: #reactor-req_put-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_put-inet6){: #reactor-req_put-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_put-into){: #reactor-req_put-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_put-json){: #reactor-req_put-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_put-max_redirects){: #reactor-req_put-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_put-max_retries){: #reactor-req_put-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_put-method){: #reactor-req_put-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_put-params){: #reactor-req_put-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_put-path_params_style){: #reactor-req_put-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_put-path_params){: #reactor-req_put-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_put-plug){: #reactor-req_put-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_put-pool_timeout){: #reactor-req_put-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_put-raw){: #reactor-req_put-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_put-receive_timeout){: #reactor-req_put-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_put-redirect_trusted){: #reactor-req_put-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_put-redirect){: #reactor-req_put-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_put-request){: #reactor-req_put-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_put-retry_delay){: #reactor-req_put-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_put-retry_log_level){: #reactor-req_put-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_put-retry){: #reactor-req_put-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_put-unix_socket){: #reactor-req_put-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_put-url){: #reactor-req_put-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_put.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_put-wait_for-names){: #reactor-req_put-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Put`



## reactor.req_request
```elixir
req_request name
```


Performs a request using `Req.request/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_request-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_request-name){: #reactor-req_request-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_request-adapter){: #reactor-req_request-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_request-auth){: #reactor-req_request-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_request-aws_sigv4){: #reactor-req_request-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_request-base_url){: #reactor-req_request-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_request-body){: #reactor-req_request-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_request-cache_dir){: #reactor-req_request-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_request-cache){: #reactor-req_request-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_request-compress_body){: #reactor-req_request-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_request-connect_options){: #reactor-req_request-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_request-decode_body){: #reactor-req_request-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_request-decode_json){: #reactor-req_request-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_request-finch_private){: #reactor-req_request-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_request-finch_request){: #reactor-req_request-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_request-finch){: #reactor-req_request-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_request-form_multipart){: #reactor-req_request-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_request-form){: #reactor-req_request-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_request-headers){: #reactor-req_request-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_request-http_errors){: #reactor-req_request-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_request-inet6){: #reactor-req_request-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_request-into){: #reactor-req_request-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_request-json){: #reactor-req_request-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_request-max_redirects){: #reactor-req_request-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_request-max_retries){: #reactor-req_request-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_request-method){: #reactor-req_request-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_request-params){: #reactor-req_request-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_request-path_params_style){: #reactor-req_request-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_request-path_params){: #reactor-req_request-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_request-plug){: #reactor-req_request-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_request-pool_timeout){: #reactor-req_request-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_request-raw){: #reactor-req_request-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_request-receive_timeout){: #reactor-req_request-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_request-redirect_trusted){: #reactor-req_request-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_request-redirect){: #reactor-req_request-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_request-request){: #reactor-req_request-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_request-retry_delay){: #reactor-req_request-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_request-retry_log_level){: #reactor-req_request-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_request-retry){: #reactor-req_request-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_request-unix_socket){: #reactor-req_request-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_request-url){: #reactor-req_request-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_request.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_request-wait_for-names){: #reactor-req_request-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Request`



## reactor.req_run
```elixir
req_run name
```


Performs a request using `Req.run/2`.

Note that Reactor doesn't validate any options - it simply passes them to the underlying `Req` function and assumes it will validate them.


### Nested DSLs
 * [wait_for](#reactor-req_run-wait_for)




### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`name`](#reactor-req_run-name){: #reactor-req_run-name .spark-required} | `atom` |  | A unique name for the step. Used when choosing the return value of the Reactor and for arguments into other steps |
### Options

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`adapter`](#reactor-req_run-adapter){: #reactor-req_run-adapter } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Adapter to use to make the actual HTTP request |
| [`auth`](#reactor-req_run-auth){: #reactor-req_run-auth } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Sets request authentication |
| [`aws_sigv4`](#reactor-req_run-aws_sigv4){: #reactor-req_run-aws_sigv4 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the AWS options to sign request |
| [`base_url`](#reactor-req_run-base_url){: #reactor-req_run-base_url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, the request URL is prepended with this base URL |
| [`body`](#reactor-req_run-body){: #reactor-req_run-body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request body |
| [`cache_dir`](#reactor-req_run-cache_dir){: #reactor-req_run-cache_dir } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The directory to store the cache |
| [`cache`](#reactor-req_run-cache){: #reactor-req_run-cache } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If `true`, performs HTTP caching |
| [`compress_body`](#reactor-req_run-compress_body){: #reactor-req_run-compress_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, compresses the request body using gzip |
| [`connect_options`](#reactor-req_run-connect_options){: #reactor-req_run-connect_options } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Dynamically starts (or re-uses already started) Finch pool with the given connection options |
| [`decode_body`](#reactor-req_run-decode_body){: #reactor-req_run-decode_body } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response body decoding |
| [`decode_json`](#reactor-req_run-decode_json){: #reactor-req_run-decode_json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Options to pass to `Jason.decode!/2` |
| [`finch_private`](#reactor-req_run-finch_private){: #reactor-req_run-finch_private } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A map or keyword list of private metadata to add to the Finch request |
| [`finch_request`](#reactor-req_run-finch_request){: #reactor-req_run-finch_request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A function that executes the Finch request, defaults to using `Finch.request/3` |
| [`finch`](#reactor-req_run-finch){: #reactor-req_run-finch } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The Finch pool to use. Defaults to pool automatically started by `Req` |
| [`form_multipart`](#reactor-req_run-form_multipart){: #reactor-req_run-form_multipart } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `multipart/form-data` |
| [`form`](#reactor-req_run-form){: #reactor-req_run-form } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as `application/x-www-form-urlencoded` |
| [`headers`](#reactor-req_run-headers){: #reactor-req_run-headers } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request headers as a `{key, value}` enumerable (e.g. map, keyword list) |
| [`http_errors`](#reactor-req_run-http_errors){: #reactor-req_run-http_errors } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How to manage 4xx and 5xx responses |
| [`inet6`](#reactor-req_run-inet6){: #reactor-req_run-inet6 } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, uses IPv6 |
| [`into`](#reactor-req_run-into){: #reactor-req_run-into } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Where to send the response body |
| [`json`](#reactor-req_run-json){: #reactor-req_run-json } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, encodes the request body as JSON |
| [`max_redirects`](#reactor-req_run-max_redirects){: #reactor-req_run-max_redirects } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The maximum number of redirects, defaults to `10` |
| [`max_retries`](#reactor-req_run-max_retries){: #reactor-req_run-max_retries } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Maximum number of retry attempts, defaults to `3` (for a total of `4` requests to the server, including the initial one) |
| [`method`](#reactor-req_run-method){: #reactor-req_run-method } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request method, defaults to `:get` |
| [`params`](#reactor-req_run-params){: #reactor-req_run-params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, appends parameters to the request query string (via `put_params` step) |
| [`path_params_style`](#reactor-req_run-path_params_style){: #reactor-req_run-path_params_style } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | How path params are expressed (via `put_path_params` step) |
| [`path_params`](#reactor-req_run-path_params){: #reactor-req_run-path_params } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, uses a templated request path (via `put_path_params` step) |
| [`plug`](#reactor-req_run-plug){: #reactor-req_run-plug } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, calls the given plug instead of making an HTTP request over the network (via `run_plug` step) |
| [`pool_timeout`](#reactor-req_run-pool_timeout){: #reactor-req_run-pool_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Pool checkout timeout in milliseconds, defaults to `5000` |
| [`raw`](#reactor-req_run-raw){: #reactor-req_run-raw } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `true`, disables automatic body decompression (`decompress_body` step) and decoding (`decode_body` step) |
| [`receive_timeout`](#reactor-req_run-receive_timeout){: #reactor-req_run-receive_timeout } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | Socket receive timeout in milliseconds, defaults to `15_000` |
| [`redirect_trusted`](#reactor-req_run-redirect_trusted){: #reactor-req_run-redirect_trusted } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | By default, authorization credentials are only sent on redirects with the same host, scheme and port. If `:redirect_trusted` is set to `true`, credentials will be sent to any host |
| [`redirect`](#reactor-req_run-redirect){: #reactor-req_run-redirect } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set to `false`, disables automatic response redirects |
| [`request`](#reactor-req_run-request){: #reactor-req_run-request } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | A previously built request |
| [`retry_delay`](#reactor-req_run-retry_delay){: #reactor-req_run-retry_delay } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If not set, which is the default, the retry delay is determined by the value of retry-delay header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ... |
| [`retry_log_level`](#reactor-req_run-retry_log_level){: #reactor-req_run-retry_log_level } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The log level to emit retry logs at. Can also be set to `false` to disable logging these messages. Defaults to `:warning` |
| [`retry`](#reactor-req_run-retry){: #reactor-req_run-retry } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | One of `:safe_transient` (default), `:transient`, `fun` or `false` |
| [`unix_socket`](#reactor-req_run-unix_socket){: #reactor-req_run-unix_socket } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | If set, connect through the given UNIX domain socket |
| [`url`](#reactor-req_run-url){: #reactor-req_run-url } | `nil \| Reactor.Template.Element \| Reactor.Template.Input \| Reactor.Template.Result \| Reactor.Template.Value` |  | The request URL |


## reactor.req_run.wait_for
```elixir
wait_for names
```


Wait for the named step to complete before allowing this one to start.

Desugars to `argument :_, result(step_to_wait_for)`




### Examples
```
wait_for :create_user
```



### Arguments

| Name | Type | Default | Docs |
|------|------|---------|------|
| [`names`](#reactor-req_run-wait_for-names){: #reactor-req_run-wait_for-names .spark-required} | `atom \| list(atom)` |  | The name of the step to wait for. |






### Introspection

Target: `Reactor.Dsl.WaitFor`




### Introspection

Target: `Reactor.Req.Dsl.Run`



<style type="text/css">.spark-required::after { content: "*"; color: red !important; }</style>
